/**
 * Return a Uint8Array of an ethereum hex-encoded key (EthHex)
 * @param   keystring is the EthHex encoding of the value
 * @param   littleEndian is true if the keystring should be interpreted as
 *          little endian. Otherwise, defaults to big endian.
 * @returns the byte incoding of the value
 */
export function parseHex(keystring, littleEndian) {
    if (littleEndian === void 0) { littleEndian = false; }
    if (keystring.indexOf('0x') === 0) {
        keystring = keystring.substr(2);
    }
    if (keystring.length % 2 === 1) {
        keystring = '0' + keystring;
    }
    var key = keystring.match(/.{2}/g);
    if (key === null) {
        return new Uint8Array();
    }
    if (littleEndian) {
        key = key.reverse();
    }
    return new Uint8Array(key.map(function (byte) { return parseInt(byte, 16); }));
}
/**
 * Returns an ethereum hex-encoded key of a Uint8Array
 * @param {Uint8Array} keybytes
 * @returns {String} The EthHex encoding
 */
export function toHex(keybytes) {
    // Already a hex string so return.
    if (typeof keybytes === 'string') {
        if (!keybytes.startsWith('0x')) {
            return '0x' + keybytes;
        }
        return keybytes;
    }
    return keybytes.reduce(function (str, byte) { return str + byte.toString(16).padStart(2, '0'); }, '0x');
}
/**
 * @returns a Uint8Array representation of number with numBytes.
 * @param   number is the number of which we want a byte representation.
 * @param   numBytes is the number of bytes to have in the resultant array.
 * @param   littleEndian is true iff the resultant byte array is little Endian.
 * @throws  if the resultant array will be longer than numBytes.
 */
export function parseNumber(num, numBytes, littleEndian) {
    if (littleEndian === void 0) { littleEndian = false; }
    var numberHexStr = num.toString(16);
    if (numberHexStr.length > numBytes) {
        throw Error("cannot parse " + num + " into a byte array of length " + numBytes);
    }
    numberHexStr = '0'.repeat(numBytes * 2 - numberHexStr.length) + numberHexStr;
    return parseHex(numberHexStr, littleEndian);
}
/**
 * @returns a newly allocated Uint8Array of all arrays concatenated together.
 */
export function concat(arrays) {
    var size = 0;
    arrays.forEach(function (a) { return (size += a.length); });
    var concatenated = new Uint8Array(size);
    var start = 0;
    arrays.forEach(function (a) {
        concatenated.set(a, start);
        start += a.length;
    });
    return concatenated;
}
/**
 * decodeUtf8 is a string decoding utility for both node and browsers.
 */
export function decodeUtf8(array) {
    var decoder = 
    // tslint:disable-next-line
    typeof TextDecoder === 'undefined'
        ? // @ts-ignore
            new (require('util')).TextDecoder('utf-8') // Node.
        : new TextDecoder('utf-8'); // Browser.
    // @ts-ignore
    return decoder.decode(array);
}
/**
 * encodeUtf8 is a string encoding utility for both node and browsers.
 */
export function encodeUtf8(input) {
    var encoder = 
    // tslint:disable-next-line
    typeof TextEncoder === 'undefined'
        ? // @ts-ignore
            new (require('util')).TextEncoder('utf-8') // Node.
        : new TextEncoder(); // Browser.
    // @ts-ignore
    return encoder.encode(input);
}
/**
 * Converts the given byte array to a number. Cannot parse a number
 * larger than u64, specifically, 2**53-1 (javascripts max number).
 */
export function toNumber(bytes, le) {
    if (le === void 0) { le = false; }
    if (bytes.length > 8) {
        throw new Error('Cannot parse a number greater than u64');
    }
    var b = toHex(bytes).substr(2);
    if (le) {
        var match = b.match(/../g);
        if (match !== null) {
            b = match.reverse().join('');
        }
    }
    var result = parseInt(b, 16);
    if (result >= Number.MAX_SAFE_INTEGER) {
        throw new Error("Overflowed when converting to number: " + bytes);
    }
    return result;
}
//# sourceMappingURL=bytes.js.map