var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { bytes } from '@oasislabs/common';
var DeployHeaderError = /** @class */ (function (_super) {
    __extends(DeployHeaderError, _super);
    function DeployHeaderError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DeployHeaderError;
}(Error));
export { DeployHeaderError };
// TODO: change all apis here to take Uint8Arrays as input/output instead
//       of hex strings.
var DeployHeader = /** @class */ (function () {
    /**
     * @param {Number} version is the header version number.
     * @param {Object} is the header body with two fields, expiry (Number)
     *        and confidential (boolean).
     */
    function DeployHeader(version, body) {
        this.version = version;
        this.body = body;
    }
    DeployHeader.prototype.data = function () {
        var version = DeployHeaderWriter.version(this.version);
        var body = DeployHeaderWriter.body(this.body);
        if (body.length % 2 !== 0) {
            throw new DeployHeaderError('Invalid body length');
        }
        var length = DeployHeaderWriter.size(body);
        if (length.substr(2).length > 4) {
            throw new DeployHeaderError('Length of the contract deploy header must be no greater than two bytes');
        }
        return ('0x' +
            DeployHeader.prefix() +
            version.substr(2) +
            length.substr(2) +
            body.substr(2));
    };
    /**
     * @param   {Object} headerBody is the header object to encode.
     * @param   {String} deploycode is a hex string of the current code to which we
     *          want to prefix the header.
     * @returns The deploycode with the header prefixed as the encoded wire format, i.e.,
     *          b'\0sis' || version (2 bytes little endian) || length (2 bytes little endian) || json-header.
     *          Overrides any header fields that may already exist in the deploycode.
     */
    DeployHeader.deployCode = function (headerBody, deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        DeployHeader.deployCodePreconditions(headerBody, deploycode);
        if (Object.keys(headerBody).length === 0) {
            // All apis should return buffers not hex strings.
            return bytes.parseHex(deploycode.substr(2));
        }
        // Read the existing header, if it exists.
        var currentHeader = DeployHeaderReader.header(deploycode);
        // Hex code to create the contract without the serialized deploy header prepended.
        var initcode;
        // No header so just make a new one. The initcode is the given deploycode.
        if (currentHeader === null) {
            currentHeader = new DeployHeader(DeployHeader.currentVersion(), {});
            initcode = deploycode;
        }
        // Extract the initcode from the deploy code.
        else {
            initcode = DeployHeaderReader.initcode(deploycode);
        }
        if (headerBody) {
            Object.assign(currentHeader.body, headerBody);
        }
        var code = currentHeader.data() + initcode.substr(2);
        // All apis should return buffers not hex strings.
        return bytes.parseHex(code.substr(2));
    };
    DeployHeader.deployCodePreconditions = function (headerBody, deploycode) {
        if (!deploycode.startsWith('0x')) {
            throw new Error('Malformed deploycode');
        }
        if (!headerBody) {
            throw new Error('No header given');
        }
        if (!DeployHeader.isValidBody(headerBody)) {
            throw new Error('Malformed deploycode or header');
        }
    };
    /**
     * @returns true iff the keys in the headerBody are part of the valid set.
     */
    DeployHeader.isValidBody = function (headerBody) {
        var validKeys = ['expiry', 'confidential'];
        var keys = Object.keys(headerBody);
        for (var k = 0; k < keys.length; k += 1) {
            if (!validKeys.includes(keys[k])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns the current version of the header.
     */
    DeployHeader.currentVersion = function () {
        return 1;
    };
    /**
     * Hex representation of b'\0sis'.
     */
    DeployHeader.prefix = function () {
        return '00736973';
    };
    return DeployHeader;
}());
export { DeployHeader };
/**
 * A collection of utilities for parsing through deploycode including the Oasis contract
 * deploy header in the form of a hex string.
 */
// TODO: change return values to be Bytes.
var DeployHeaderReader = /** @class */ (function () {
    function DeployHeaderReader() {
    }
    /**
     * @param   {String} deploycode is the transaction data to deploy a contract as a hex string.
     * @returns the contract deploy header prefixed to the deploycode, otherwise, null.
     */
    DeployHeaderReader.header = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            return null;
        }
        var version = DeployHeaderReader.version(deploycode);
        var body = DeployHeaderReader.body(deploycode);
        if (!DeployHeader.isValidBody(body)) {
            throw Error("Invalid body " + JSON.stringify(body));
        }
        return new DeployHeader(version, body);
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.body = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            throw new DeployHeaderError('code must have the header prefiix');
        }
        var length = DeployHeaderReader.size(deploycode);
        var serializedBody = deploycode.substr(DeployHeaderReader.bodyStart(), length * 2);
        return JSON.parse(bytes.decodeUtf8(bytes.parseHex(serializedBody)));
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.size = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        var length = deploycode.substr(DeployHeaderReader.sizeStart(), DeployHeaderReader.sizeLength());
        return parseInt('0x' + length, 16);
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.version = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        var version = deploycode.substr(DeployHeaderReader.versionStart(), DeployHeaderReader.versionLength());
        return parseInt('0x' + version, 16);
    };
    /**
     * @param {String} deploycode is a hex string of the header || initcode.
     */
    DeployHeaderReader.initcode = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        return ('0x' + deploycode.substr(DeployHeaderReader.initcodeStart(deploycode)));
    };
    DeployHeaderReader.initcodeStart = function (deploycode) {
        if (typeof deploycode !== 'string') {
            deploycode = bytes.toHex(deploycode);
        }
        if (!deploycode.startsWith('0x' + DeployHeader.prefix())) {
            throw new DeployHeaderError('code must have the header prefix');
        }
        // Make sure to convert the "length" to nibbles, since it's in units of bytes.
        return (DeployHeaderReader.bodyStart() + DeployHeaderReader.size(deploycode) * 2);
    };
    /**
     * @returns the hex string index of the start section.
     */
    DeployHeaderReader.versionStart = function () {
        return 2 + DeployHeader.prefix().length;
    };
    /**
     * @returns the length of the version in nibbles.
     */
    DeployHeaderReader.versionLength = function () {
        return 2 * 2;
    };
    /**
     * @returns the index of the starting point of the size section.
     */
    DeployHeaderReader.sizeStart = function () {
        return (DeployHeaderReader.versionStart() + DeployHeaderReader.versionLength());
    };
    /**
     * @returns the length of the header size in nibbles.
     */
    DeployHeaderReader.sizeLength = function () {
        return 2 * 2;
    };
    /**
     * @returns the hex string index of the body section.
     */
    DeployHeaderReader.bodyStart = function () {
        return DeployHeaderReader.sizeStart() + DeployHeaderReader.sizeLength();
    };
    return DeployHeaderReader;
}());
export { DeployHeaderReader };
// TODO: change return values to be Bytes.
var DeployHeaderWriter = /** @class */ (function () {
    function DeployHeaderWriter() {
    }
    DeployHeaderWriter.size = function (body) {
        if (typeof body !== 'string') {
            body = bytes.toHex(body);
        }
        return bytes.toHex(bytes.parseNumber(body.substr(2).length / 2, 2));
    };
    DeployHeaderWriter.version = function (version) {
        return bytes.toHex(bytes.parseNumber(version, DeployHeaderReader.versionLength() / 2));
    };
    DeployHeaderWriter.body = function (body) {
        return bytes.toHex(bytes.encodeUtf8(JSON.stringify(body)));
    };
    return DeployHeaderWriter;
}());
export { DeployHeaderWriter };
// Alias.
function parseHex(deploycode) {
    return DeployHeaderReader.header(deploycode);
}
// Convenience api export.
export var header = {
    parseHex: parseHex
};
//# sourceMappingURL=header.js.map